#include "drape_frontend/car3d.hpp"

#include "drape_frontend/color_constants.hpp"
#include "drape_frontend/visual_params.hpp"

#include "shaders/program_manager.hpp"

#include "drape/texture_manager.hpp"

#include "indexer/map_style_reader.hpp"
#include "indexer/scales.hpp"

#include "geometry/screenbase.hpp"
#include "defines.hpp"
#include <android/log.h>
#include <vulkan/vulkan_core.h>
#include "3party/tinyobjloader/tiny_obj_loader.h"

namespace df
{
namespace car3d {
double constexpr kCarSize = 12.0;
double constexpr kCar3dScaleMin = 1.0;
double constexpr kCar3dScaleMax = 2.2;
int constexpr kCar3dMinZoom = 16;
}  // namespace car3d

//float constexpr kOutlineScale = 1.2f;
//
int constexpr kCarComponentsInVertex = 3;
int constexpr kCarComponentsInNormal = 3;
int constexpr kCarComponentsInText = 2;

struct Vertex {
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec3 color;
    glm::vec2 uv;
};

df::ColorConstant const kCar3DShadowColor = "Car3DShadow";
df::ColorConstant const kCar3DObsoleteColor = "Car3DObsolete";
df::ColorConstant const kCar3DColor = "Car3D";
df::ColorConstant const kCar3DOutlineColor = "Car3DOutline";

std::string getDownloadDirectoryPath() {
    const char* downloadDir = getenv("EXTERNAL_STORAGE");
    if (downloadDir != nullptr) {
        std::string downloadPath(downloadDir);
        downloadPath += "/Download";
        return downloadPath;
    }

    return "";
}

static std::string GetBaseDir(const std::string & filepath)
{
  if (filepath.find_last_of("/\\") != std::string::npos)
    return filepath.substr(0, filepath.find_last_of("/\\"));
  return "";
}

Car3d::Car3d(ref_ptr<dp::GraphicsContext> context)
  : m_carMesh(context, dp::CustomMeshObject::DrawPrimitive::Triangles)
  , m_state(CreateRenderState(gpu::Program::Car3d, DepthLayer::OverlayLayer))
{
  m_state.SetDepthTestEnabled(false);

  std::string filename = "/storage/emulated/0/Android/data/app.organicmaps.debug/files/10000001/model.obj";
  std::string base_dir = GetBaseDir(filename);
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# Filename = %s", filename.c_str());
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# Base dir = %s", base_dir.c_str());

  if (base_dir.empty())
  {
    base_dir = ".";
  }

  base_dir += "/";

  tinyobj::attrib_t inattrib;
  std::vector<tinyobj::shape_t> inshapes;
  std::vector<tinyobj::material_t> materials;
  std::map<std::string, uint32_t> textures;

  std::string warn;
  std::string err;
  tinyobj::LoadObj(&inattrib, &inshapes, &materials, &warn, &err, filename.c_str(), base_dir.c_str());
  if (!warn.empty())
  {
    std::cout << "WARN: " << warn << std::endl;
  }
  if (!err.empty())
  {
    std::cerr << err << std::endl;
  }

  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# of vertices  = %d", (int)(inattrib.vertices.size()) / 3);
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# of normals   = %d", (int)(inattrib.normals.size()) / 3);
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# of normals generated by meshObject  = %d", (int)(dp::CustomMeshObject::GenerateNormalsForTriangles(inattrib.vertices, kComponentsInVertex).size()) / 3);
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# of texcoords = %d", (int)(inattrib.texcoords.size()) / 2);
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# of materials = %d", (int)materials.size());
  __android_log_print(ANDROID_LOG_INFO, "TinyObj", "# of shapes    = %d", (int)inshapes.size());

  std::vector<float> vertices = inattrib.vertices;

  std::vector<float> normals = inattrib.normals;

  std::vector<float> texcoords = inattrib.texcoords;

  std::vector<float> buffer;

  std::vector<Vertex> _vertices;
  std::vector<std::string> _materials;

  for (size_t s = 0; s < inshapes.size(); s++) {
    // Loop over faces(polygon)
    size_t index_offset = 0;
    int material_id = inshapes[s].mesh.material_ids[0]; // get the material ID for this shape
    tinyobj::material_t material = materials[material_id]; // get the material from the ID

    if(material.diffuse_texname != "") {
      auto material_path = base_dir + material.diffuse_texname;
      _materials.push_back(material_path);
    }

    __android_log_print(ANDROID_LOG_INFO, "TinyObj", "material = %s", material.name.c_str());
    for (size_t f = 0; f < inshapes[s].mesh.num_face_vertices.size(); f++) {

      //hardcode loading to triangles
      int fv = 3;

      // Loop over vertices in the face.
      for (int v = 0; v < fv; v++) {
        // access to vertex
        tinyobj::index_t idx = inshapes[s].mesh.indices[index_offset + v];

        //vertex position
        tinyobj::real_t vx = inattrib.vertices[3 * idx.vertex_index + 0];
        tinyobj::real_t vy = inattrib.vertices[3 * idx.vertex_index + 1];
        tinyobj::real_t vz = inattrib.vertices[3 * idx.vertex_index + 2];
        //vertex normal
        tinyobj::real_t nx = inattrib.normals[3 * idx.normal_index + 0];
        tinyobj::real_t ny = inattrib.normals[3 * idx.normal_index + 1];
        tinyobj::real_t nz = inattrib.normals[3 * idx.normal_index + 2];

        //copy it into our vertex
        Vertex new_vert;
        new_vert.position.x = vx;
        new_vert.position.y = vy;
        new_vert.position.z = vz;

        new_vert.normal.x = nx;
        new_vert.normal.y = ny;
        new_vert.normal.z = nz;

        //we are setting the vertex color as the vertex normal. This is just for display purposes
        new_vert.color = new_vert.normal;

        tinyobj::real_t ux = inattrib.texcoords[2 * idx.texcoord_index + 0];
        tinyobj::real_t uy = inattrib.texcoords[2 * idx.texcoord_index + 1];

        new_vert.uv.x = ux;
        new_vert.uv.y = 1-uy;

        _vertices.push_back(new_vert);
      }
      index_offset += fv;
    }
  }

  // Load _vertices using setBuffer
  // Loop over _vertices and push into a new vector position

  std::vector<tinyobj::real_t> copiedVertices;

  for(auto const & vert : _vertices)
  {
    copiedVertices.push_back(vert.position.x);
    copiedVertices.push_back(vert.position.y);
    copiedVertices.push_back(vert.position.z);
  }

  auto constexpr kVerticesBufferInd = 0;
  m_carMesh.SetBuffer(kVerticesBufferInd, std::move(copiedVertices),
                      sizeof(float) * kCarComponentsInVertex);
  m_carMesh.SetAttribute("a_pos", kVerticesBufferInd, 0 /* offset */, kCarComponentsInVertex);

    std::vector<tinyobj::real_t> copiedNormals;

    for(auto const & vert : _vertices)
    {
        copiedNormals.push_back(vert.normal.x);
        copiedNormals.push_back(vert.normal.y);
        copiedNormals.push_back(vert.normal.z);
    }

    auto constexpr kNormalsBufferInd = 1;
    m_carMesh.SetBuffer(kNormalsBufferInd, std::move(copiedNormals), sizeof(float) * kCarComponentsInNormal);
    m_carMesh.SetAttribute("a_normal", kNormalsBufferInd, 0 /* offset */, kCarComponentsInNormal);

    std::vector<tinyobj::real_t> copiedTexcoords;

    for(auto const & vert : _vertices)
    {
        copiedTexcoords.push_back(vert.uv.x);
        copiedTexcoords.push_back(vert.uv.y);
    }

    auto constexpr kTexcoordsBufferInd = 2;
    m_carMesh.SetBuffer(kTexcoordsBufferInd, std::move(copiedTexcoords), sizeof(float) * kCarComponentsInText);
    m_carMesh.SetAttribute("a_texcoord", kTexcoordsBufferInd, 0 /* offset */, kCarComponentsInText);

    for (size_t i = 0; i < _materials.size(); i++)
    {
      m_carMesh.SetTexture(i, _materials[i]);
    }
}

// static
double Car3d::GetMaxBottomSize()
{
  double const kBottomSize = 1.0;
  return kBottomSize * car3d::kCarSize * car3d::kCar3dScaleMax * kOutlineScale;
}

void Car3d::SetPosition(const m2::PointD & position)
{
  m_position = position;
}

void Car3d::SetAzimuth(double azimuth)
{
  m_azimuth = azimuth;
}

void Car3d::SetTexture(ref_ptr<dp::TextureManager> texMng)
{
  m_state.SetColorTexture(texMng->GetSymbolsTexture());
}

void Car3d::SetPositionObsolete(bool obsolete)
{
  m_obsoletePosition = obsolete;
}

void Car3d::Render(ref_ptr<dp::GraphicsContext> context, ref_ptr<gpu::ProgramManager> mng,
                     ScreenBase const & screen, bool routingMode)
{
  dp::Color const color =
    df::GetColorConstant(m_obsoletePosition ? df::kCar3DObsoleteColor : df::kCar3DColor);

  RenderCar(context, mng, m_carMesh, screen, gpu::Program::Car3d, color, 0.0f /* dz */,
              2.0f /* scaleFactor */);
}

void Car3d::RenderCar(ref_ptr<dp::GraphicsContext> context, ref_ptr<gpu::ProgramManager> mng,
                          dp::CustomMeshObject & mesh, ScreenBase const & screen, gpu::Program program,
                          dp::Color const & color, float dz, float scaleFactor)
{
  gpu::Car3dProgramParams params;
  math::Matrix<float, 4, 4> const modelTransform = CalculateTransform(screen, dz, scaleFactor,
                                                                      context->GetApiVersion());
  params.m_transform = glsl::make_mat4(modelTransform.m_data);
  params.m_color = glsl::ToVec4(color);

  auto gpuProgram = mng->GetProgram(program);
  mesh.Render(context, gpuProgram, m_state, mng->GetParamsSetter(), params);
}

math::Matrix<float, 4, 4> Car3d::CalculateTransform(ScreenBase const & screen, float dz,
                                                      float scaleFactor, dp::ApiVersion apiVersion) const
{
  double carScale = VisualParams::Instance().GetVisualScale() * car3d::kCarSize * scaleFactor;
  if (screen.isPerspective())
  {
    double const t = GetNormalizedZoomLevel(screen.GetScale(), car3d::kCar3dMinZoom);
    carScale *= (car3d::kCar3dScaleMin * (1.0 - t) + car3d::kCar3dScaleMax * t);
  }

  auto const scaleX = static_cast<float>(carScale * 2.0 / screen.PixelRect().SizeX());
  auto const scaleY = static_cast<float>(carScale * 2.0 / screen.PixelRect().SizeY());
  auto const scaleZ = static_cast<float>(screen.isPerspective() ? (0.002 * screen.GetDepth3d()) : 1.0);

  m2::PointD const pos = screen.GtoP(m_position);
  auto const dX = static_cast<float>(2.0 * pos.x / screen.PixelRect().SizeX() - 1.0);
  auto const dY = static_cast<float>(2.0 * pos.y / screen.PixelRect().SizeY() - 1.0);

  math::Matrix<float, 4, 4> scaleM = math::Identity<float, 4>();
  scaleM(0, 0) = scaleX;
  scaleM(1, 1) = scaleY;
  scaleM(2, 2) = scaleZ;

  math::Matrix<float, 4, 4> rotateX = math::Identity<float, 4>();
  rotateX(1, 1) = cos(-M_PI / 2);
  rotateX(1, 2) = -sin(-M_PI / 2);
  rotateX(2, 1) = sin(-M_PI / 2);
  rotateX(2, 2) = cos(-M_PI / 2);

  math::Matrix<float, 4, 4> rotateY = math::Identity<float, 4>();
  rotateY(0, 0) = cos(m_azimuth + screen.GetAngle());
  rotateY(0, 2) = sin(m_azimuth + screen.GetAngle());
  rotateY(2, 0) = -sin(m_azimuth + screen.GetAngle());
  rotateY(2, 2) = cos(m_azimuth + screen.GetAngle());

  math::Matrix<float, 4, 4> rotate180 = math::Identity<float, 4>();
  rotate180(0, 0) = cos(M_PI);
  rotate180(0, 2) = sin(M_PI);
  rotate180(2, 0) = -sin(M_PI);
  rotate180(2, 2) = cos(M_PI);

  math::Matrix<float, 4, 4> translateM = math::Identity<float, 4>();
  translateM(3, 0) = dX;
  translateM(3, 1) = -dY;
  translateM(3, 2) = 0;

  math::Matrix<float, 4, 4> modelTransform = rotateY * rotateX * rotate180 * scaleM * translateM;
  if (screen.isPerspective())
    return modelTransform * math::Matrix<float, 4, 4>(screen.Pto3dMatrix());

  if (apiVersion == dp::ApiVersion::Metal)
  {
    modelTransform(3, 2) = modelTransform(3, 2) + 0.5f;
    modelTransform(2, 2) = modelTransform(2, 2) * 0.5f;
  }

  return modelTransform;
}
}  // namespace df
